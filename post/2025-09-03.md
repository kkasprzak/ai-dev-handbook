# TDD Flow z Claude Code: System Komend @tdd/ do Kontroli AI-Assisted Development

_3 września 2025_

## Wprowadzenie

Po kilku miesiącach pracy z Claude Code w projektach Solidity i PHP, stworzyłem system komend `@tdd/` który pomaga kontrolować AI-assisted development. Ten post opisuje ewolucję mojego flow pracy i rozwiązania problemów napotkanych podczas pair programmingu z AI.

## Problem: Kontrola nad AI w TDD

Podczas pracy z Claude Code zidentyfikowałem problemy w przestrzeganiu zasad TDD:

- **Pisze kod produkcyjny przed testami**
- **Implementuje wiele funkcji jednocześnie** zamiast podejścia step-by-step
- **Zapomina o refactoringu** po przejściu testów na zielono
- **Traci kontekst** między sesjami roboczymi

Z retrospektywy z lipca 2025:

> "Claude had trouble smoothly switching between the acceptance test and the unit test. Once he wrote the acceptance test, he immediately started implementing the logic in the class and forgot that he should also create a test case in the unit test first."

## Rozwiązanie: System Komend @tdd/

Obecna struktura komend @tdd/ jest wynikiem iteracyjnej pracy – powstała w toku kolejnych eksperymentów, obserwacji i adaptacji. Nie był to jednorazowy akt stworzenia, lecz proces ciągłego doskonalenia: eksperymentuję, analizuję wyniki i wprowadzam zmiany. Aktualnie korzystam z czterech głównych komend, ale ten zestaw i ich rola mogą się zmieniać wraz z dalszym rozwojem i nowymi wnioskami.

### 1. `@tdd/rules/remind` - Przypomnienie Roli

**Cel**: Odświeżenie kontekstu o procesie implementacji i roli w sesji
**Kiedy używać**: Na początku sesji lub gdy Claude traci fokus na TDD

```markdown
Please read CLAUDE.md and remind ourselves what our implementation process is
and what our role is in this session
```

### 2. `@tdd/rules/violations` - Kontrola Naruszeń

**Cel**: Identyfikacja i korekta łamania zasad TDD
**Kiedy używać**: Gdy Claude pisze kod bez testów lub łamie Red-Green-Refactor

Ta komenda wymusza analizę:

- Mandatory TDD steps: Write ONE failing test → Run → Minimal implementation → Run → Refactor
- Rule about ONE test at a time
- Prohibition against writing features without tests first
- Red-Green-Refactor cycle violations

### 3. `@tdd/session/save` – Zapisanie Kontekstu

**Cel**: Strukturalne notatki z sesji pair programmingu, które nie tylko dokumentują postęp, ale przede wszystkim przygotowują kompletny i zwięzły kontekst do późniejszego wznowienia pracy. Komenda ta jest ściśle powiązana z funkcją „Wznowienie Pracy” – dobre notatki minimalizują koszt przełączania kontekstu i pozwalają Navigatorowi szybko przypomnieć sobie, na czym skończyliśmy. Dzięki temu powrót do zadania po przerwie jest znacznie łatwiejszy i bardziej efektywny.

Generuje notatki w formacie:

```markdown
# Session Notes - [Date/Time]

## Feature Summary

[2-3 sentence summary]

## Current Status

• [Status point 1]
• [Status point 2]

## Next Tasks

• [Task 1]
• [Task 2]

## Important Reminders

• [Critical notes]
```

### 4. `@tdd/session/resume` – Wznowienie Pracy

**Cel**: Ułatwienie Navigatorowi (czyli mnie) szybkiego odzyskania kontekstu po przerwie w pracy. Ludzki umysł ma naturalne ograniczenia w przełączaniu się między zadaniami – powrót do przerwanego wątku bywa czasochłonny i wymaga odświeżenia pamięci. Ta komenda powstała właśnie po to, by zminimalizować czas potrzebny na przypomnienie sobie, gdzie skończyłem zadanie, i umożliwić płynne wznowienie pracy bez zbędnego szukania informacji.

Analizuje `.ai/session_notes.md` i proponuje:

- Co robiliśmy (1-2 zdania)
- Immediate next action (konkretny krok)
- Current Status (lista punktów)
- Next Tasks (kolejne zadania)
- Quick Start (komendy do uruchomienia)

## Kluczowe Zasady Flow

### AI-Human Pair Programming Model

**Navigator (Ja)**: Strategiczne decyzje, architektura, przegląd kodu
**Driver (Claude)**: Pisanie kodu, wykonywanie komend, implementacja

**Zasada**: Claude prosi o pozwolenie przed każdym krokiem TDD.

Przykład komunikacji:

```
Driver: "Should I write a failing test for [specific behavior]?"
Navigator: "Yes, start with time-based trigger validation"
Driver: "Test created and failing. May I proceed to implement minimal solution?"
Navigator: "Yes, implement just the time check"
```

### TDD Process

Przestrzeganie cyklu:

1. **RED**: Napisz jeden failujący test
2. **GREEN**: Minimalna implementacja dla przejścia testu
3. **REFACTOR**: Poprawa kodu przy zachowaniu zielonych testów

### Kontrola Jakości

- xUnit Test Patterns jako fundament
- Business-focused test naming
- Creation Methods dla clean setup'u
- Consistent patterns w całym projekcie

## Ewolucja i Uczenie Się

### Wczesne Odkrycia (Lipiec 2025)

> "Writing test cases and implementing based on the written test went well. Claude stuck well to the acceptance test and then the implementation."

Ale też pierwsze problemy:

> "Claude had trouble smoothly switching between the acceptance test and the unit test."

### Rozwój Systemu (Sierpień 2025)

Wprowadzenie pair programming rules:

> "Pair programming works well where AI is the driver and I am the navigator. I have rules for this written in CLAUDE.md and the AI listens quite well."

### Bieżący Stan (Wrzesień 2025)

Wykorzystuję dodatkowo:

- Output styles (Junior developer mentee, Code review terror)
- Specialized subagents (Product Owner, Smart Contract Auditor)
- Plan mode (`Shift+Tab`) dla lepszego planowania
- Session continuity poprzez structured notes

## Praktyczne Korzyści

### 1. **Konsekwentność Procesu**

Powtarzalny TDD flow dla różnych zadań.

### 2. **Zachowanie Kontroli**

Strategiczne decyzje pozostają przy człowieku.

### 3. **Kontrola Jakości**

Procedury zapobiegające pominięciu testów lub refactoringu.

### 4. **Ciągłość Między Sesjami**

Zapisywanie kontekstu i wznowienie pracy.

### 5. **Uniwersalność**

System używany w PHP, Solidity, TypeScript/React.

## Kluczowe Insights z Retrospektyw

### AI w Nowych Obszarach

> "Switching to another technology with Claude Code is easier—I can start delivering value faster."

### Potrzeba Balansu z Niezależnym Kodowaniem

> "Since AI writes code more and more often, I notice that I should also write on my own to maintain this skill."

### Plan Mode

> "I spend more time discussing the plan with Claude Code, and when I see the plan is solid, I switch to accept-on-edit mode so it writes the full implementation."

## Dalszy Rozwój

Testuję dodatkowo:

- Specialized subagents (Product Owner, Code Reviewer)
- Output styles dostosowane do kontekstu (Learning, Code review terror)
- Tooling integration (Puppeteer MCP, PostgreSQL MCP)
- Ulepszenia session continuity

## Plany rozwoju: Komenda do notatek w stylu Becka

Jednym z moich kolejnych celów jest wprowadzenie dedykowanej komendy, która pozwoli mi szybko i w sposób ustrukturyzowany zapisywać notatki w trakcie pracy – dokładnie tak, jak robi to Kent Beck w „Test-Driven Development: By Example”. Chcę, aby można było łatwo dodawać:

- TODO-listy (rzeczy do zrobienia, kolejne testy, refaktoryzacje)
- obserwacje i wątpliwości pojawiające się podczas implementacji
- pomysły na usprawnienia lub techniczny dług do spłacenia później

Taka komenda pozwoli mi nie tylko lepiej zarządzać kontekstem i planem działania, ale też ułatwi wznowienie pracy po przerwie oraz systematyczne porządkowanie kodu.

W duchu praktyk Kenta Becka planuję również zostawiać na koniec sesji niezaimplementowany test case. To prosty, ale skuteczny sposób na przypomnienie sobie, od czego zacząć kolejną sesję – dzięki temu powrót do pracy jest bardziej płynny i nie tracę czasu na ponowne odnajdywanie właściwego miejsca w cyklu TDD.

## Balansowanie kontroli nad AI – inspiracja suwakiem Karpathy’ego

Obecnie mój system pracy z asystentem AI opiera się na pełnej kontroli – trzymam AI na „krótkiej smyczy” poprzez ścisły proces TDD i własne komendy. Takie podejście minimalizuje ryzyko błędów i pozwala zachować wysoką jakość kodu, ale ma też swoją cenę: nie wykorzystuję w pełni potencjału AI do przyspieszania pracy. Gdybym przeszedł na tryb „vibe coding”, w którym AI ma większą autonomię i generuje rozwiązania na podstawie ogólnych wskazówek, mógłbym osiągnąć większą szybkość, ale kosztem potencjalnego długu technicznego i utraty kontroli nad jakością.

Spostrzeżenia Andreja Karpathy’ego o „suwaku autonomii” dobrze oddają ten dylemat – z jednej strony pełna kontrola, z drugiej pełna swoboda AI. Obecnie eksperymentuję z różnymi ustawieniami tego suwaka, szukając złotego środka, który pozwoli mi efektywnie łączyć bezpieczeństwo i jakość z szybkością i elastycznością pracy z AI. Właśnie w tym kierunku podążają moje dalsze eksperymenty z asystentami AI w programowaniu.

## Refaktoryzacja z AI – wyzwania i plany

Wielokrotnie zauważyłem, że AI zna wszystkie popularne metody refaktoryzacji (np. split phase, extract method, replace temp with query, replace primitive with object), ale nie stosuje ich samodzielnie bez wyraźnej instrukcji. Jak zapisałem w retrospektywie:

> "LLM, jeśli mu powiesz co zrobić, zrobi to, ale sam nie potrafi połączyć kropek jak człowiek. Co ciekawe, zna te metody bardzo dobrze—zawsze, gdy pytam, tłumaczy je bezbłędnie. Ale nie potrafi samodzielnie zdecydować, że powinien ich użyć w danym kontekście."

Podobnie:

> "Działa dobrze, gdy konkretnie nazwę refaktoryzację, którą chcę, żeby wykonał. Asystent zna je wszystkie, więc nie muszę tłumaczyć krok po kroku."

Obecnie szukam sposobu na usprawnienie procesu refaktoryzacji z AI. Być może pojawią się tu nowe komendy (np. szybkie oznaczanie miejsc do refaktoryzacji na później) lub rozszerzenie CLAUDE.md o projektowe wzorce refaktoryzacji. Chciałbym, aby refaktoryzacja była bardziej naturalną częścią cyklu pracy z AI, a nie tylko reakcją na moje polecenia.

## Podsumowanie

System komend `@tdd/` pomaga kontrolować AI-assisted development przez strukturyzację procesu TDD. Główne założenie to zachowanie ludzkiej kontroli nad strategicznymi decyzjami przy wykorzystaniu AI do implementacji.

Efekty:

- Kontrola nad kodem pozostaje przy człowieku
- AI pomaga w implementacji
- Procedury zapobiegają pominięciu testów
- Możliwość pracy w różnych technologiach
- Ciągłość między sesjami

System dostarcza struktury potrzebne do efektywnej pracy z AI w TDD.
